package pkg;

import pkg.Node;
import pkg.Query;


import java.io.IOException;
import java.net.*;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

import javax.sip.ClientTransaction;
import javax.sip.Dialog;
import javax.sip.DialogTerminatedEvent;
import javax.sip.IOExceptionEvent;
import javax.sip.ListeningPoint;
import javax.sip.RequestEvent;
import javax.sip.ResponseEvent;
import javax.sip.ServerTransaction;
import javax.sip.SipException;
import javax.sip.SipFactory;
import javax.sip.SipListener;
import javax.sip.SipProvider;
import javax.sip.SipStack;
import javax.sip.TimeoutEvent;
import javax.sip.TransactionTerminatedEvent;
import javax.sip.address.*;
import javax.sip.address.URI;
import javax.sip.header.*;
import javax.sip.message.*;
import javax.swing.*;
import javax.swing.table.*;
import org.apache.log4j.BasicConfigurator;

/**
 *
 * @author ArshiaHsn,RaziehRoustaei,MaryamAmini,HosseinNassiri
 */

public class Server extends javax.swing.JFrame implements SipListener {

    private SipFactory sipFactory;
    private SipStack sipStack;
    private SipProvider sipProvider;
    private MessageFactory messageFactory;
    private HeaderFactory headerFactory;
    private AddressFactory addressFactory;
    private ListeningPoint listeningPoint;
    
    private Properties properties;
    private String ip;
    private int port;
    private String protocol = "udp";
    private int tag = (new Random()).nextInt();
    private Address contactAddress;
    private ContactHeader contactHeader;
    private	List<String> Registered_Clients;
    private Node server;
    private Query dataBase;
    


    public InetAddress getCurrentIp() {
        try {
            Enumeration<NetworkInterface> networkInterfaces = NetworkInterface
                    .getNetworkInterfaces();
            while (networkInterfaces.hasMoreElements()) {
                NetworkInterface ni = (NetworkInterface) networkInterfaces
                        .nextElement();
                Enumeration<InetAddress> nias = ni.getInetAddresses();
                while(nias.hasMoreElements()) {
                    InetAddress ia= (InetAddress) nias.nextElement();
                    if (!ia.isLinkLocalAddress() 
                     && !ia.isLoopbackAddress()
                     && ia instanceof Inet4Address) {
                        return ia;
                    }
                }
            }
        } catch (SocketException e) {
        	System.out.println("unable to get current IP " + e.getMessage());
        }
        return null;
    }
	
    /*
     * Tree implementation
     * Subdomains and arbiters
     */
 
    /**
     * Creates new form SipRegistrar
     */
    public Server() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    

    private void initComponents() {

        jScrollPaneTable = new javax.swing.JScrollPane();
        jTable = new javax.swing.JTable();
        jScrollPaneText = new javax.swing.JScrollPane();
        jTextArea = new javax.swing.JTextArea();
        Registered_Clients = new ArrayList<String>();
        server = new Node();
        dataBase = new Query();

        
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("SIP Server");
        setLocationByPlatform(true);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowOpened(java.awt.event.WindowEvent evt) {
                onOpen();
            }
        });
        

        
        jTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
               "URI", "From", "To",  "Call-ID", "Request/Response"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPaneTable.setViewportView(jTable);
        jTextArea.setEditable(false);
        jTextArea.setColumns(20);
        jTextArea.setRows(5);
        jScrollPaneText.setViewportView(jTextArea);
        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPaneTable, javax.swing.GroupLayout.DEFAULT_SIZE, 600, Short.MAX_VALUE)
            .addComponent(jScrollPaneText)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
             .addGroup(javax.swing.GroupLayout.Alignment.TRAILING,layout.createSequentialGroup()
             .addContainerGap()
             .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
             .addComponent(jScrollPaneTable, javax.swing.GroupLayout.DEFAULT_SIZE, 294, Short.MAX_VALUE)
             .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
             .addComponent(jScrollPaneText, javax.swing.GroupLayout.PREFERRED_SIZE, 127, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
        
        //main
        BasicConfigurator.configure();
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(this.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(this.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(this.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(this.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                setVisible(true);
            }
        });
    }// </editor-fold>//GEN-END:initComponents

    private void onOpen() {//GEN-FIRST:event_onOpen
        try {
            this.ip = getCurrentIp().toString().substring(1);
            this.port = 5060;
            this.sipFactory = SipFactory.getInstance();
            this.sipFactory.setPathName("gov.nist");
            this.properties = new Properties();
            this.properties.setProperty("javax.sip.STACK_NAME", "stack");
            this.sipStack = this.sipFactory.createSipStack(this.properties);
            this.messageFactory = this.sipFactory.createMessageFactory();
            this.headerFactory = this.sipFactory.createHeaderFactory();
            this.addressFactory = this.sipFactory.createAddressFactory();
            this.listeningPoint = this.sipStack.createListeningPoint("0.0.0.0", this.port, this.protocol);
            this.sipProvider = this.sipStack.createSipProvider(this.listeningPoint);
            this.sipProvider.addSipListener(this);
            this.contactAddress = this.addressFactory.createAddress("sip:" + this.ip + ":" + this.port);
            this.contactHeader = this.headerFactory.createContactHeader(contactAddress);
            this.jTextArea.append("Local address: " + this.ip + ":" + this.port + "\n");
        }
        catch(Exception e) {
            JOptionPane.showMessageDialog(this, e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_onOpen

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPaneTable;
    private javax.swing.JScrollPane jScrollPaneText;
    private javax.swing.JTable jTable;
    private javax.swing.JTextArea jTextArea;
    // End of variables declaration//GEN-END:variables
    

    @Override
    public void processRequest(RequestEvent requestEvent) {
        // Get the request.
        Request request = requestEvent.getRequest();      
        this.jTextArea.append("\nRECV " + request.getMethod()); //+ " " + request.getRequestURI().toString());

        try {
            // Get or create the server transaction.
            ServerTransaction transaction = requestEvent.getServerTransaction();
            if(null == transaction) {
                transaction = this.sipProvider.getNewServerTransaction(request);
            }

            // Process the request and send a response.
            Response response ;
            if(request.getMethod().equals("REGISTER")) {
                // If the request is a REGISTER.
                String portAndIpTemp = request.getHeader("From")+"";
                String IpTemp = portAndIpTemp.substring(portAndIpTemp.indexOf("<")+5, portAndIpTemp.lastIndexOf(":"));
                String nameTemp = request.getHeader("To")+"";
                nameTemp = nameTemp.substring((nameTemp.indexOf("<")+5), (nameTemp.indexOf("@")));
                if(!Registered_Clients.contains(nameTemp))
                {	//The first time client is registering, do everything!
                	// Update the SIP message table.
                    this.updateTable(requestEvent, request, transaction);
                    //API call
                	Runtime.getRuntime().exec("update_server user "+nameTemp+" "+IpTemp);
                	//add Client's name to list, so next time just update the db.
                	Registered_Clients.add(nameTemp);
                	this.jTextArea.append(nameTemp + "   " + (nameTemp+"@"+portAndIpTemp));
                	response = this.messageFactory.createResponse(200, request);	
                	((ToHeader)response.getHeader("To")).setTag(String.valueOf(this.tag));
                	response.addHeader(this.contactHeader);
                	transaction.sendResponse(response);
                }
                else {
                	//we have registered this client before, just update the db.
                }   Runtime.getRuntime().exec("update_server user "+nameTemp+" "+IpTemp);             
            }
            else if(request.getMethod().equals("MESSAGE")) {
                // If the request is a MESSAGE.
            	// Update the SIP message table.
                this.updateTable(requestEvent, request, transaction);
                String tempId = ""+request.getHeader("To");
                tempId = tempId.substring((tempId.indexOf("<")+5), (tempId.indexOf("@")));
                //Extracting sip address of the sender
                String tempSenderSipAddress = ""+request.getHeader("From");
                tempSenderSipAddress = tempSenderSipAddress.substring((tempSenderSipAddress.indexOf("<")+1), (tempSenderSipAddress.indexOf(">")));
                //Extracting destination server address
                String tempDestinationServerAddress = ""+request.getHeader("To");
                tempDestinationServerAddress = tempDestinationServerAddress.substring((tempDestinationServerAddress.indexOf("@")+1),(tempDestinationServerAddress.indexOf(">")));
                tempDestinationServerAddress = "sip:"+tempDestinationServerAddress;
                //Extracting destination sip address
                String tempDestinationSipAddress = ""+request.getHeader("To");
                tempDestinationSipAddress = tempDestinationSipAddress.substring((tempDestinationSipAddress.indexOf("<")+1),(tempDestinationSipAddress.indexOf(">")));
                URI requestURI = this.addressFactory.createAddress(tempDestinationServerAddress).getURI();
                //If destination is registered in this server, send it, else forward it to the appropriate server
                String tempDest = Query.query_user(tempId);
                //System.out.println("client : " + tempDest);
                String destinationRequestUri = "sip:"+tempDest+":5060";
                //System.out.println("Destination URI: "+destinationRequestUri);
                URI requestURI3 = this.addressFactory.createAddress(destinationRequestUri).getURI();
                //NEW
                if(tempDest != null)
                {
                    this.jTextArea.append("\nMessage sent!\n");
                    sendMessage(request,"sip:"+tempId+"@"+tempDest+":5060",requestURI3,1);
                }
                else
                {
                	//Destination not found, send to parent
                	String tempParent = Query.query_parent();
                	if(tempParent!=null)
                	{
                        String parentRequestUri = "sip:"+tempParent+":5060";
                    	URI requestURI2 = this.addressFactory.createAddress(parentRequestUri).getURI();
                    	//If parent is not null send to parent, else discard;
                		sendMessage(request,tempDestinationSipAddress,requestURI2,0);
                    	this.jTextArea.append("\nForwarding.\n");
                	}
                	else
                	{
                		//The Big Father, if he dosn't have the name, no one has it      		
                		System.out.print("\nIn Big Father");
                		// The "Max-Forwards" header.
                	    MaxForwardsHeader maxForwardsHeader = this.headerFactory.createMaxForwardsHeader(70);
                	    // The "Call-Id" header.
                	    CallIdHeader callIdHeader = this.sipProvider.getNewCallId();
                	    // The "CSeq" header.
                	    CSeqHeader cSeqHeader = (CSeqHeader)request.getHeader(CSeqHeader.NAME);
                	    //The "To" header
                        String to = request.getHeader(ContactHeader.NAME).toString();
                        String TempSipAddress = to.substring((to.indexOf("<")+1),(to.indexOf(">")));
                        String to_IP = TempSipAddress.substring(TempSipAddress.indexOf(":")+1 , TempSipAddress.lastIndexOf(":"));
                		System.out.println("\nSending 404 to : " + TempSipAddress);
                		Address addressTo = this.addressFactory.createAddress(TempSipAddress);
                		ToHeader toHeader = this.headerFactory.createToHeader(addressTo, null);
                	    // The "From" header.
                		FromHeader fromHeader = (FromHeader) request.getHeader(FromHeader.NAME); 
                		//The Via Header
                    	ArrayList<ViaHeader> viaHeaders = new ArrayList<ViaHeader>();
                	    ViaHeader viaHeader = this.headerFactory.createViaHeader(to_IP, this.port, "udp", null);
                	    viaHeaders.add(viaHeader);
                	    // Creating the MESSAGE .
                	    response = this.messageFactory.createResponse(
                	    		404,
                	    		callIdHeader,
                	    		cSeqHeader,
                	    		fromHeader,
                	    		toHeader,
                	    		viaHeaders,
                	    		maxForwardsHeader);

                	    // Add the "Contact" header to the request.
                	    response.setHeader(request.getHeader(ContactHeader.NAME));
                	    ((ToHeader)response.getHeader("To")).setTag(String.valueOf(this.tag));
                	    // Send the response
                	    this.sipProvider.sendResponse(response);
                	    this.jTextArea.append("\nUser not found! Sendig 404 to Client...\n");
                	    
                	}
                }

            }
            	else if(request.getMethod().equals("INVITE")) {
                // If the request is an INVITE.
            	// Update the SIP message table.
                this.updateTable(requestEvent, request, transaction);
                response = this.messageFactory.createResponse(200, request);
                ((ToHeader)response.getHeader("To")).setTag(String.valueOf(this.tag));
                response.addHeader(this.contactHeader);
                transaction.sendResponse(response);
                this.jTextArea.append(" / SENT " + response.getStatusCode() + " " + response.getReasonPhrase());
                String temp = ""+request.getHeader("To");
                String temp2 = ""+request.getHeader("From");
                temp = temp.substring((temp.indexOf("<")+1), (temp.indexOf("@")));
                sendMessage(server.getDataBase().get(temp), new String(request.getRawContent()),temp2,this.addressFactory.createAddress(temp).getURI());
                
            }

            else if(request.getMethod().equals("BYE")) {
                // If the request is a BYE.
            	// Update the SIP message table.
                this.updateTable(requestEvent, request, transaction);
                response = this.messageFactory.createResponse(200, request);
                ((ToHeader)response.getHeader("To")).setTag(String.valueOf(this.tag));
                response.addHeader(this.contactHeader);
                transaction.sendResponse(response);
                this.jTextArea.append(" / SENT " + response.getStatusCode() + " " + response.getReasonPhrase());
            }
        }
        catch(SipException e) {
            this.jTextArea.append("\nERROR (SIP) in Process Request : " + e.getMessage());
        }
        catch(Exception e) {
            this.jTextArea.append("\nERROR in Process Request : " + e.getMessage());
        }
    }

    public void sendMessage(String to, String msg, String from, javax.sip.address.URI requestURI) {
    	try {

    	    // Get the destination address from the text field.
    	    Address addressTo = this.addressFactory.createAddress(to);
    	    Address addressFrom = this.addressFactory.createAddress(from);
    	    // Create the SIP message headers.
    	    
    	    // The "Via" headers.
    	    ArrayList<ViaHeader> viaHeaders = new ArrayList<ViaHeader>();
    	    ViaHeader viaHeader = this.headerFactory.createViaHeader(this.ip, this.port, "udp", null);
    	    viaHeaders.add(viaHeader);
    	    // The "Max-Forwards" header.
    	    MaxForwardsHeader maxForwardsHeader = this.headerFactory.createMaxForwardsHeader(70);
    	    // The "Call-Id" header.
    	    CallIdHeader callIdHeader = this.sipProvider.getNewCallId();
    	    // The "CSeq" header.
    	    CSeqHeader cSeqHeader = this.headerFactory.createCSeqHeader(1L,"MESSAGE");
    	    // The "From" header.
    	    FromHeader fromHeader = this.headerFactory.createFromHeader(addressFrom, String.valueOf(this.tag));
    	    // The "To" header.
    	    ToHeader toHeader = this.headerFactory.createToHeader(addressTo, null);

    	    // Creating the MESSAGE .
    	    Request request = this.messageFactory.createRequest(
    	        requestURI,
    	        "MESSAGE",
    	        callIdHeader,
    	        cSeqHeader,
    	        fromHeader,
    	        toHeader,
    	        viaHeaders,
    	        maxForwardsHeader);
    	    // Add the "Contact" header to the request.
    	    request.addHeader(contactHeader);
    	    ContentTypeHeader contentTypeHeader = headerFactory.createContentTypeHeader("text", "plain");
    		request.setContent(msg, contentTypeHeader);

    	    // Send the request statelessly through the SIP provider.
    	    this.sipProvider.sendRequest(request);

    	    // Display the message in the text area.
    	    this.jTextArea.append("\nRequest sent to:\n" + addressTo);
    	}
    	catch(Exception e) {
    	    // If an error occurred, display the error.
    	    this.jTextArea.append("Request sent failed: " + e.getMessage() + "\n");
    	}
    }
    public void sendMessage(Request request, String to, URI requestURI, int isFound) {
    	try {

    	    // Get the destination address from the text field.
    	    Address addressTo = this.addressFactory.createAddress(to);
    	    // Create the SIP message headers.
    	    
    	    // The "Via" headers.
    	    List<ViaHeader> viaHeaders = new ArrayList<ViaHeader>();
    	    ViaHeader viaHeader = this.headerFactory.createViaHeader(this.ip, this.port, "udp", null);
    	    viaHeaders.add((ViaHeader) request.getHeader(ViaHeader.NAME));
    	    viaHeaders.add(viaHeader); 
    	    // The "Max-Forwards" header.
    	    MaxForwardsHeader maxForwardsHeader = (MaxForwardsHeader) request.getHeader(MaxForwardsHeader.NAME);
    	    maxForwardsHeader.setMaxForwards(maxForwardsHeader.getMaxForwards()-1);
    	    if(maxForwardsHeader.getMaxForwards() == 0)
    	    {
                Response response = this.messageFactory.createResponse
                (Response.TOO_MANY_HOPS,request);			
                sipProvider.sendResponse(response);
    	    }
    	    // The "Call-Id" header.
    	    CallIdHeader callIdHeader = (CallIdHeader) request.getHeader(CallIdHeader.NAME);
    	    // The "CSeq" header.
    	    CSeqHeader cSeqHeader = (CSeqHeader) request.getHeader(CSeqHeader.NAME);
    	    // The "From" header.
    	    FromHeader fromHeader = (FromHeader) request.getHeader(FromHeader.NAME);
    	    // The "To" header.
    	    ToHeader toHeader = this.headerFactory.createToHeader(addressTo, null);

    	    // Creating the MESSAGE .
    	    Request requestNew = this.messageFactory.createRequest(
    	        requestURI,
    	        "MESSAGE",
    	        callIdHeader,
    	        cSeqHeader,
    	        fromHeader,
    	        toHeader,
    	        viaHeaders,
    	        maxForwardsHeader);
    	    // Add the "Contact" header to the request, make it transparent to the client
    	    if(isFound == 1)
    	    	requestNew.addHeader(contactHeader);
    	    else
    	    	requestNew.addHeader(request.getHeader(ContactHeader.NAME));
    	    
    	    ContentTypeHeader contentTypeHeader = headerFactory.createContentTypeHeader("text", "plain");
    	    requestNew.setContent(request.getRawContent(), contentTypeHeader);


    	    // Send the request statelessly through the SIP provider.
    	    this.sipProvider.sendRequest(requestNew);

    	    // Display the message in the text area.
    	    this.jTextArea.append("\nRequest sent to:\n" + addressTo);
    	}
    	catch(Exception e) {
    	    // If an error occurred, display the error.
    	    this.jTextArea.append("\nRequest sent failed: " + e.getMessage());
    	}
    }

    @Override
    public void processResponse(ResponseEvent responseEvent) {
      
        System.out.println("\nA response arrived !!!");
        Response response = responseEvent.getResponse();
        //this.jTextArea.append("\nRECV Respone " + response);
        this.updateTable(responseEvent, response);
        
        try {
                
                if(response.getStatusCode()== Response.NOT_FOUND) {
                	//new 404 response arrived
                	System.out.println("Got 404 response from " + response.getHeader("From"));
            	    // The "Max-Forwards" header.
            	    MaxForwardsHeader maxForwardsHeader = this.headerFactory.createMaxForwardsHeader(70);
            	    // The "Call-Id" header.
            	    CallIdHeader callIdHeader = this.sipProvider.getNewCallId();
            	    // The "CSeq" header.
            	    CSeqHeader cSeqHeader = this.headerFactory.createCSeqHeader(1L,"Response");
            	    //The "To" header
                    String to = response.getHeader(ContactHeader.NAME).toString();
                    String tempDestinationSipAddress = to.substring((to.indexOf("<")+1),(to.indexOf(">")));
                    String to_IP = tempDestinationSipAddress.substring(tempDestinationSipAddress.indexOf(":")+1 , tempDestinationSipAddress.lastIndexOf(":"));
            		System.out.println("\nSending 404 to : " + tempDestinationSipAddress);
            		Address addressTo = this.addressFactory.createAddress(tempDestinationSipAddress);
            		ToHeader toHeader = this.headerFactory.createToHeader(addressTo, null);
            	    // The "From" header.
            		FromHeader fromHeader = (FromHeader) response.getHeader(FromHeader.NAME); 
            		//The Via Header
                	ArrayList<ViaHeader> viaHeaders = new ArrayList<ViaHeader>();
            	    ViaHeader viaHeader = this.headerFactory.createViaHeader(to_IP, this.port, "udp", null);
            	    viaHeaders.add(viaHeader);
            	    // Creating the MESSAGE .
            	    Response new_response = this.messageFactory.createResponse(
            	    		404,
            	    		callIdHeader,
            	    		cSeqHeader,
            	    		fromHeader,
            	    		toHeader,
            	    		viaHeaders,
            	    		maxForwardsHeader);

            	    // Add the "Contact" header to the request.
            	    new_response.setHeader(response.getHeader(ContactHeader.NAME));
            	    ((ToHeader)new_response.getHeader("To")).setTag(String.valueOf(this.tag));
            	    // Send the response
            	    this.sipProvider.sendResponse(new_response);
            	    this.jTextArea.append("\nUser not found!");
                }
                else if(response.getStatusCode()== Response.OK){
                	//200 OK response, we should route it to the expected client
                	System.out.println("\nGot 200 OK");
                	//Extracting sip address of receiver
                    String to = ""+response.getHeader("To");
                    String tempReceiverSipAddress = to.substring((to.indexOf("<")+5), (to.indexOf("@")));
                    //Extracting destination server address
                    String tempDestinationServerAddress = to.substring((to.indexOf("@")+1),(to.indexOf(">")));
                    tempDestinationServerAddress = "sip:"+tempDestinationServerAddress;
                    //If destination is registered in this server, send it, else forward it to the appropriate server
                    String tempDest = Query.query_user(tempReceiverSipAddress);
                    System.out.println("\ntahesh "+tempDest);
                    //System.out.println("client : " + tempDest);
                    if(tempDest != null)
                    {
                    	//the Server has the Destination client too, so it just forwards the response to it.
                    	this.jTextArea.append("\n200 OK(Seen) sent!\n");
                    	//decrement from Max Forwards
                	    MaxForwardsHeader maxForwardsHeader = (MaxForwardsHeader) response.getHeader(MaxForwardsHeader.NAME);
                	    maxForwardsHeader.setMaxForwards(maxForwardsHeader.getMaxForwards()-1);
                	    //Via Header
                	    ArrayList<ViaHeader> viaHeaders = new ArrayList<ViaHeader>();
                	    ViaHeader viaHeader = this.headerFactory.createViaHeader(tempDest, 5060, "udp", null);
                	    viaHeaders.add(viaHeader);
                	    //CallIdHeader
                	    CallIdHeader callIdHeader = (CallIdHeader)response.getHeader(CallIdHeader.NAME);
                	    // The "CSeq" header.
                	    CSeqHeader cSeqHeader = (CSeqHeader)response.getHeader(CSeqHeader.NAME);
                	    //The "To" header
                		ToHeader toHeader = (ToHeader)response.getHeader(ToHeader.NAME);
                	    // The "From" header.
                		FromHeader fromHeader = (FromHeader) response.getHeader(FromHeader.NAME); 
                	    // Creating the MESSAGE .
                	    Response new_response = this.messageFactory.createResponse(
                	    		200,
                	    		callIdHeader,
                	    		cSeqHeader,
                	    		fromHeader,
                	    		toHeader,
                	    		viaHeaders,
                	    		maxForwardsHeader);

                	    // Add the "Contact" header to the request.
                	    new_response.setHeader(response.getHeader(ContactHeader.NAME));
                	    ((ToHeader)new_response.getHeader("To")).setTag(String.valueOf(this.tag));
                	    // Send the response
                	    this.sipProvider.sendResponse(new_response);
                	    //System.out.println(new_response.toString());
                        
                    }
                    else
                    {
                    	//Destination not found, send 200 OK to parent
                    	String tempParent = Query.query_parent();
                    	if(tempParent!=null)
                    	{
                        	//If parent is not null send to parent, else discard;
                        	this.jTextArea.append("\nFprwarding 200 OK(Seen)!\n");
                        	//decrement from Max Forwards
                    	    MaxForwardsHeader maxForwardsHeader = (MaxForwardsHeader) response.getHeader(MaxForwardsHeader.NAME);
                    	    maxForwardsHeader.setMaxForwards(maxForwardsHeader.getMaxForwards()-1);
                    	    //Via Header
                    	    ArrayList<ViaHeader> viaHeaders = new ArrayList<ViaHeader>();
                    	    ViaHeader viaHeader = this.headerFactory.createViaHeader(tempParent, 5060, "udp", null);
                    	    viaHeaders.add(viaHeader);
                    	    //CallIdHeader
                    	    CallIdHeader callIdHeader = (CallIdHeader)response.getHeader(CallIdHeader.NAME);
                    	    // The "CSeq" header.
                    	    CSeqHeader cSeqHeader = (CSeqHeader)response.getHeader(CSeqHeader.NAME);
                    	    //The "To" header
                    		ToHeader toHeader = (ToHeader)response.getHeader(ToHeader.NAME);
                    	    // The "From" header.
                    		FromHeader fromHeader = (FromHeader) response.getHeader(FromHeader.NAME); 
                    	    // Creating the MESSAGE .
                    	    Response new_response = this.messageFactory.createResponse(
                    	    		200,
                    	    		callIdHeader,
                    	    		cSeqHeader,
                    	    		fromHeader,
                    	    		toHeader,
                    	    		viaHeaders,
                    	    		maxForwardsHeader);

                    	    // Add the "Contact" header to the request.
                    	    new_response.setHeader(response.getHeader(ContactHeader.NAME));
                    	    ((ToHeader)new_response.getHeader("To")).setTag(String.valueOf(this.tag));
                    	    // Send the response
                    	    this.sipProvider.sendResponse(new_response);
                    	    //System.out.println(new_response.toString());
                    	}
                    }
                }

            }
            catch(Exception e) {
                this.jTextArea.append("\nERROR in Process Response : " + e.getMessage());
            }
    }

    @Override
    public void processTimeout(TimeoutEvent timeoutEvent) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void processIOException(IOExceptionEvent exceptionEvent) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void processTransactionTerminated(TransactionTerminatedEvent transactionTerminatedEvent) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public void processDialogTerminated(DialogTerminatedEvent dialogTerminatedEvent) {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    private void updateTable(RequestEvent requestEvent, Request request, ServerTransaction transaction) {
        // Get the table model.
        DefaultTableModel tableModel = (DefaultTableModel) this.jTable.getModel();
        // Get the headers.
        FromHeader from = (FromHeader)request.getHeader("From");
        //System.out.println("1 " + request.getRequestURI().toString());
        ToHeader to = (ToHeader)request.getHeader("To");
        CallIdHeader callId = (CallIdHeader)request.getHeader("Call-Id");
        CSeqHeader cSeq = (CSeqHeader)request.getHeader("CSeq");
        // Get the SIP dialog.
        Dialog dialog = transaction.getDialog();
        // Add a new line to the table.
        tableModel.addRow(new Object[] {
            request.getRequestURI() != null ? request.getRequestURI().toString() : "(unknown)",
            from != null ? from.getAddress() : "(unknown)",
            to != null ? to.getAddress() : "(unknown)",
            callId != null ? callId.getCallId() : "(unknown)",
            cSeq != null ? cSeq.getSeqNumber() + " " + cSeq.getMethod() : "(unknown)",
            dialog != null ? dialog.getDialogId() : "",
            transaction.getBranchId(),
            "Request",
            request.getMethod() });
    }

    private void updateTable(ResponseEvent requestEvent, Response response) {
        try{
        	// Get the table model.
        	DefaultTableModel tableModel = (DefaultTableModel) this.jTable.getModel();
        	// Get the headers.
        	FromHeader from = (FromHeader)response.getHeader("From");
        	//System.out.println("1 " + request.getRequestURI().toString());
        	ToHeader to = (ToHeader)response.getHeader("To");
        	CallIdHeader callId = (CallIdHeader)response.getHeader("Call-Id");
        	CSeqHeader cSeq = (CSeqHeader)response.getHeader("CSeq");
        	//Get Response type
        	String Type = String.valueOf(response.getStatusCode());
        	//System.out.println("\ntype is : "+Type);
        	
        	// Add a new line to the table.
        	tableModel.addRow(new Object[] {
        			"sip:" + getCurrentIp().toString().substring(1) + ":" + this.port,
        			from != null ? from.getAddress() : "(unknown)",
        			to != null ? to.getAddress() : "(unknown)",
        			callId != null ? callId.getCallId() : "(unknown)",
        			cSeq != null ? Type + " Response" : "(unknown)",
        			"Response",
        			Type});}
        catch (Exception e) {
			// TODO: handle exception
        	System.out.println("\nError in Response Update Table : "+e.getMessage());
		}
    }
    
}
